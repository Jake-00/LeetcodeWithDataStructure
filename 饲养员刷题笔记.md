## Part1 数据结构

1. 数组
2. 链表
3. 队列



### 1.1 数组 

#### 重点：区分==访问（Accesas）==和==搜索（Search）==

* 访问:arrow_right:索引
* 搜索:arrow_right:元素

#### 四部曲时间复杂度

1. 访问（Access）：O(1)
2. 搜索（Search）：O(n)
3. 插入（Insert）：O(n)
4. 删除（Delete）：O(n)

#### 应用场景

##### 	==读多写少==

#### 基础语法:point_down:

| 常用操作     | python3                                                      | Java                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1.创建数组   | a = []                                                       | int[] a = {1,2,3};<br/>int[] b = new int[]{1,2,3};<br/>int[] c = new int[3];<br/>ArrayList<Integer> arr = new ArrayList<>() |
| 2.添加元素   | a.append()<br/>a.insert(index,element)                       | arr.add(element);<br/>arr.add(index, element);               |
| 3.访问元素   | a[index]                                                     | arr.get(index);<br/>a[index];                                |
| 4.修改元素   | a[index] = new_num                                           | arr[index] = new_num;<br/>arr.set(index, element);           |
| 5.删除元素   | a.remove(element)<br/>a.pop(index)<br/>a.pop()  # 最后一个元素 | arr.remove(index)                                            |
| 6.遍历元素   | for e in a<br/>for index, element in enumerate(a)<br/>for i in range(len(a)): | for (int i = 0; i < arr.length; i++)<br/>for  (int i = 0; i < arr.size(); i++) |
| 7.查找元素   | a.index(index)                                               | boolean is99 = arr.contains(99);                             |
| 8.数组的长度 | len(a)                                                       | arr.length<br/>arr.size()                                    |
| 9.数组排序   | a.sort()<br/>a.sort(reverse = True)                          | Array.sort(arr);<br/>Collection.sort(arr);                   |

#### 练习题：

485. ##### 最大连续1的个数

解法一：更新最大和

```
func(nums)->int:
    if nums is null or nums.length == 0
    	return 0
    count = 0
    result = 0
    for (i = 0; i < nums.length; i = i+1)
    	if nums[i] == 1
    		count = count+1
    	else
    		result = max(result,count)
    		count = 0
    result = max(result,count)
    return result		
```

解法二：滑动窗口

```python
```

#### Leetcode练习题

485. ##### 移动零

486. ##### 移动元素



### 1.2 链表
#### 四部曲时间复杂度

1. 访问（Access）：O(n)

2. 搜索（Search）：O(n)

3. 插入（Insert）：O(1)

4. 删除（Delete）：O(1)

#### Leetcode练习题

leetcode 203：单向链表要先考虑两件事 （1）需不需要dummy head （2）需要多少个移动指针，除了遍历其他都是2个以上



leetcode 206：

​	解法一：反转链表需要3个指针

​	解法二：新建一个dummy head，需要两个移动指针，每次遍历到一个元素就尾插进dummy head的链表中

​	解法三：递归，还没细想





### 1.3 队列

#### 特点：先进先出（FIFO：First In First Out）

#### 分类：

1. 单端队列 Queue
2. 双端队列 Deque

#### 四部曲时间复杂度（就是链表）

1. 访问（Access）：O(n)
2. 搜索（Search）：O(n)
3. 插入（Insert）：O(1)
4. 删除（Delete）：O(1)

#### 队列基本操作

##### 出入队原则：左头右尾，头进尾出

![image-20210506213005820](饲养员刷题笔记.assets/image-20210506213005820.png)

| 常用操作   | Python3 | Java |
| ---------- | ------- | ---- |
| 1.创建队列 | from collections import deuqe<br/>q = deque() | import java.util.LinkedList;<br>import java.util.Queue;<br><br/>Queue<String> queue = new LinkedList<String>(); |
| 2.添加元素（==入队==） | q.appendleft(element) | queue.offer("a"); |
| 3.获取即将出队的元素 | tmp = q[-1] | string tmp = queue.peek(); |
| 4.删除元素（==出队==） | q.pop() | queue.poll(); |
| 5.判断队列是否为空 | if len(q): | queue.isEmpty(); |
| 6.队列长度 | len(q) | queue.size(); |
| 7.遍历队列（==边删除边遍历==） | while len(q):<br/>    print(q.pop()) | for (queue.size() > 0) {<br/>    tmp = q.poll();<br/>    System.out.println(tmp);<br/>} |
|  |  |  |

#### Leetcode练习题

933.最近的请求次数

python3

```python
from collections import deque

class RecentCounter:

    def __init__(self):
        # 1.初始化一个队列
        self.q = deque()

    def ping(self, t: int) -> int:
        while len(self.q) > 0:
            # 2.获得队列的尾巴元素
            rear = self.q[-1]
            # 3.如果队头元素和即将入队元素的差大于3000，则弹出尾巴
            if t - rear > 3000:
                self.q.pop()
            else:
                break
        self.q.appendleft(t)
        return len(self.q)
```



Java

```Java
```



239.滑动窗口的最大值

